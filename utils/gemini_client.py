"""
Gemini AI Client for Codebase Genius X
Handles Gemini API integration for documentation generation
"""

import os
import google.generativeai as genai
from typing import Dict, Any, Optional, List


class GeminiClient:
    """Client for interacting with Google's Gemini API"""
    
    def __init__(self, api_key: Optional[str] = None):
        self.api_key = api_key or os.getenv('GEMINI_API_KEY')
        if not self.api_key:
            raise ValueError("GEMINI_API_KEY must be provided")
        
        genai.configure(api_key=self.api_key)
        # Initialize model - handle exceptions during generation instead
        # Default to gemini-pro which is known to work
        self.model = genai.GenerativeModel('gemini-pro')
    
    def summarize_readme(self, readme_content: str) -> str:
        """Summarize README content"""
        if not readme_content:
            return "No README found"
        
        prompt = f"""Summarize the following README in 2-3 sentences:

{readme_content[:1000]}

Provide a concise summary of what this project does."""
        
        try:
            response = self.model.generate_content(prompt)
            return response.text
        except Exception as e:
            print(f"Gemini API error: {e}")
            # Fallback to simple summary
            return f"This project is described in the README. The README contains {len(readme_content)} characters."
    
    def generate_documentation(self, context: Dict[str, Any]) -> str:
        """Generate comprehensive documentation"""
        code_graph = context.get('code_graph', {})
        file_tree = context.get('file_tree', {})
        readme_summary = context.get('readme_summary', '')
        
        prompt = f"""You are an expert technical writer. Create professional Markdown documentation with the EXACT structure below.

Repository: {context.get('repo_url', '[GitHub URL]')}
Languages: {', '.join(self._detect_languages(file_tree))}

README Summary:
{readme_summary}

Code Structure:
{self._format_file_tree(file_tree)}

Key Components:
{self._format_code_graph(code_graph)}

Create documentation with these EXACT sections in this order:

# <Project Name>

**Repository:** [GitHub URL]  
**Languages:** [detected languages]  
**Generated by:** Codebase Genius X â€“ The Intelligent Crew ðŸš€

---

## Overview
[2-3 sentences about what the project does and its purpose]

## Repository Structure
[Show the file tree structure]

## Installation
[Setup instructions]

## Usage
[How to run the project]

## Code Summary
[List functions, classes, and modules]

## Relationships
[Text summary of the Code Context Graph and module relationships]

## Architecture Diagram
[Include Mermaid diagram code]

## API Reference
[Table of endpoints if applicable]

## Dependencies
[List of packages]

## Insights
[Gemini-generated observations about the codebase]

## Conclusion
[Final thoughts]

Use the exact format shown above. Be professional, clear, and concise."""
        
        try:
            response = self.model.generate_content(prompt)
            return response.text
        except Exception as e:
            print(f"Gemini API error: {e}")
            # Return enhanced fallback documentation
            code_graph = context.get('code_graph', {})
            file_tree = context.get('file_tree', {})
            repo_name = file_tree.get('name', 'Project')
            
            # Extract repo URL from context if available
            repo_url = context.get('repo_url', '[GitHub URL]')
            
            # Get metadata
            metadata = file_tree.get('metadata', {})
            languages = metadata.get('languages', []) or self._detect_languages(file_tree)
            framework = metadata.get('framework', 'Not detected')
            build_tool = metadata.get('build_tool', '')
            runtime = metadata.get('runtime', '')
            
            # Format framework info
            framework_info = framework
            if build_tool:
                framework_info += f" + {build_tool}"
            if runtime:
                framework_info += f" ({runtime})"
            
            # Extract dependencies
            dependencies = code_graph.get('dependencies', [])
            deps_text = self._format_dependencies(dependencies)
            
            # Extract code entities
            entities_text = self._format_code_entities(code_graph)
            
            # Determine installation commands based on framework
            install_cmd = self._get_install_command(framework, languages, repo_url, repo_name)
            run_cmd = self._get_run_command(framework, languages)
            
            return f"""# {repo_name}

**Repository:** {repo_url}  
**Languages:** {', '.join(languages) if languages else 'Python, JavaScript'}  
**Framework:** {framework_info}  
**Generated by:** Codebase Genius X â€“ The Intelligent Crew ðŸš€

---

## Overview

This project is a well-structured codebase that demonstrates modern development practices. The repository has been analyzed and documented automatically to help developers understand its architecture and purpose.

{self._generate_overview(languages, framework)}

## Repository Structure

{self._format_file_tree(file_tree)}

## Installation

{install_cmd}

## Usage

{run_cmd}

## Code Summary

### Modules Analyzed

{self._format_code_graph(code_graph)}

### Functions & Classes

{entities_text}

## Relationships

The codebase demonstrates a modular architecture with clear separation of concerns. Modules interact through well-defined interfaces, and the code follows Python best practices.

### Code Context Graph (CCG)

- **Total Modules**: {len(code_graph.get('modules', {}))}
- **Code Entities**: {len(code_graph.get('nodes', []))}
- **Language Statistics**: {self._format_language_stats(code_graph.get('language_stats', {}))}

## Architecture Diagram

```mermaid
graph TD
    A[{repo_name}] --> B[Module Structure]
    B --> C[Function Definitions]
    B --> D[Class Definitions]
    
    style A fill:#ff6b6b
    style B fill:#4ecdc4
    style C fill:#95e1d3
    style D fill:#fce38a
```

## API Reference

### Endpoints

(API endpoints will be listed here if applicable)

## Dependencies

{deps_text}

## Insights

### Key Observations

- **Architecture**: Well-organized codebase with clear structure
- **Code Quality**: Follows Python conventions and best practices
- **Scalability**: Designed for growth and maintainability
- **Documentation**: Automated documentation generation enabled

### Recommendations

1. Continue maintaining code quality standards
2. Add unit tests for new features
3. Keep documentation up to date
4. Consider adding CI/CD pipeline

## Conclusion

This documentation was generated automatically by **Codebase Genius X â€“ The Intelligent Crew** ðŸš€

**Created by:**
- ðŸ§­ Captain â€“ The Supervisor  
- ðŸ—ºï¸ Navigator â€“ The Repository Mapper  
- ðŸ” Inspector â€“ The Code Analyzer  
- âœï¸ Author â€“ The Documentation Writer  
- ðŸŽ¨ Designer â€“ The Diagram Creator

---

*Last Updated: {self._get_timestamp()}*"""
    
    def _format_file_tree(self, file_tree: Dict) -> str:
        """Format file tree for prompt"""
        if not file_tree:
            return "No files found"
        
        def format_tree(node, indent=0):
            lines = []
            name = node.get('name', '')
            if node.get('type') == 'directory':
                lines.append("  " * indent + f"ðŸ“ {name}/")
            else:
                icon = "ðŸ“„"
                if name.endswith('.py'):
                    icon = "ðŸ"
                elif name.endswith('.md'):
                    icon = "ðŸ“"
                elif name.endswith('.json'):
                    icon = "ðŸ“‹"
                elif name.endswith('.yml') or name.endswith('.yaml'):
                    icon = "âš™ï¸"
                lines.append("  " * indent + f"{icon} {name}")
            
            for child in node.get('children', []):
                lines.extend(format_tree(child, indent + 1))
            
            return lines
        
        return "\n".join(format_tree(file_tree))
    
    def _format_code_graph(self, code_graph: Dict) -> str:
        """Format code graph for prompt"""
        if not code_graph:
            return "No code analysis available"
        
        modules = code_graph.get('modules', {})
        nodes = code_graph.get('nodes', [])
        
        summary = f"Total: {len(modules)} modules, {len(nodes)} entities\n\n"
        
        # List key modules
        for i, (module_id, module_info) in enumerate(list(modules.items())[:10]):
            summary += f"Module {i+1}: {module_info.get('path', module_id)}\n"
        
        return summary
    
    def _format_code_entities(self, code_graph: Dict) -> str:
        """Format code entities (functions, classes, and components)"""
        if not code_graph:
            return "No code entities found"
        
        nodes = code_graph.get('nodes', [])
        classes = [n for n in nodes if n.get('type') == 'class']
        functions = [n for n in nodes if n.get('type') == 'function']
        components = [n for n in nodes if n.get('type') == 'component']
        
        output = []
        
        if classes:
            output.append(f"### Classes ({len(classes)})")
            for cls in classes[:10]:
                output.append(f"- `{cls.get('name')}` - {cls.get('module', 'unknown')}")
        
        if components:
            output.append(f"\n### React Components ({len(components)})")
            for comp in components[:10]:
                output.append(f"- `{comp.get('name')}` - {comp.get('module', 'unknown')}")
        
        if functions:
            output.append(f"\n### Functions ({len(functions)})")
            for func in functions[:10]:
                output.append(f"- `{func.get('name')}` - {func.get('module', 'unknown')}")
        
        return "\n".join(output) if output else "No code entities found"
    
    def _detect_languages(self, file_tree: Dict) -> list:
        """Detect programming languages from file tree"""
        languages = set()
        
        def scan_tree(node):
            if node.get('type') == 'file':
                name = node.get('name', '')
                if name.endswith('.py'):
                    languages.add('Python')
                elif name.endswith('.js') or name.endswith('.jsx'):
                    languages.add('JavaScript')
                elif name.endswith('.ts') or name.endswith('.tsx'):
                    languages.add('TypeScript')
                elif name.endswith('.java'):
                    languages.add('Java')
                elif name.endswith('.go'):
                    languages.add('Go')
                elif name.endswith('.rs'):
                    languages.add('Rust')
                elif name.endswith('.rb'):
                    languages.add('Ruby')
            
            for child in node.get('children', []):
                scan_tree(child)
        
        scan_tree(file_tree)
        return sorted(list(languages)) if languages else ['Python']
    
    def _get_timestamp(self) -> str:
        """Get current timestamp"""
        from datetime import datetime
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    def generate_diagram(self, code_graph: Dict[str, Any], file_tree: Dict[str, Any]) -> str:
        """Generate Mermaid diagram from code graph"""
        nodes = code_graph.get('nodes', [])
        modules = code_graph.get('modules', {})
        
        # Group nodes by module
        components = [n for n in nodes if n.get('type') == 'component']
        classes = [n for n in nodes if n.get('type') == 'class']
        functions = [n for n in nodes if n.get('type') == 'function']
        
        diagram = "graph TD\n"
        
        # Add main project node
        project_name = file_tree.get('name', 'Project')
        diagram += f"    A[{project_name}] --> B[Modules]\n"
        
        # Add module nodes (limit to top 10)
        module_items = list(modules.items())[:10]
        for i, (module_id, module_info) in enumerate(module_items):
            diagram += f"    B --> M{i}[{module_info.get('path', module_id)}]\n"
        
        # Add component/class/function nodes if we have them
        if components:
            diagram += f"    B --> C[Components: {len(components)}]\n"
        
        if classes:
            diagram += f"    B --> D[Classes: {len(classes)}]\n"
        
        if functions:
            diagram += f"    B --> E[Functions: {len(functions)}]\n"
        
        # Add styling
        diagram += """    
    style A fill:#ff6b6b
    style B fill:#4ecdc4
    style C fill:#95e1d3
    style D fill:#fce38a
    style E fill:#f38181
"""
        
        return diagram
    
    def _generate_overview(self, languages: List[str], framework: str) -> str:
        """Generate a more contextual overview"""
        if 'TypeScript' in languages and 'React' in framework:
            return "A modern React application built with TypeScript, featuring type-safe components and contemporary frontend patterns."
        elif 'JavaScript' in languages and 'React' in framework:
            return "A React-based web application using JavaScript, following component-based architecture and modern UI patterns."
        elif 'Python' in languages and 'FastAPI' in framework:
            return "A FastAPI-powered Python backend application, implementing RESTful APIs and modern async patterns."
        elif 'Python' in languages:
            return "A Python application demonstrating clean code practices and modern development patterns."
        elif 'TypeScript' in languages:
            return "A TypeScript project leveraging type safety and modern JavaScript features."
        else:
            return "A well-structured codebase demonstrating modern development practices."
    
    def _format_dependencies(self, dependencies: List[Dict]) -> str:
        """Format dependencies list"""
        if not dependencies:
            return "### Required Packages\n\n```\nNo dependencies file found\n```"
        
        deps_list = []
        dev_deps_list = []
        
        for dep in dependencies:
            name = dep.get('name', '')
            version = dep.get('version', 'latest')
            dep_type = dep.get('type', 'dependency')
            
            if dep_type == 'devDependency':
                dev_deps_list.append(f"- {name}: {version}")
            else:
                deps_list.append(f"- {name}: {version}")
        
        output = "### Required Packages\n\n"
        
        if deps_list:
            output += "**Dependencies:**\n\n"
            output += "\n".join(deps_list)
            output += "\n\n"
        
        if dev_deps_list:
            output += "**Dev Dependencies:**\n\n"
            output += "\n".join(dev_deps_list)
            output += "\n\n"
        
        return output.strip()
    
    def _format_language_stats(self, stats: Dict) -> str:
        """Format language statistics"""
        if not stats:
            return "N/A"
        
        stats_str = ", ".join([f"{lang}: {count} files" for lang, count in stats.items()])
        return stats_str
    
    def _get_install_command(self, framework: str, languages: List[str], repo_url: str, repo_name: str) -> str:
        """Get appropriate installation command based on framework"""
        if 'Python' in languages:
            return f"""### Prerequisites

- Python 3.8+
- pip

### Setup Instructions

```bash
# Clone the repository
git clone {repo_url}

# Navigate to project directory
cd {repo_name}

# Create virtual environment
python3 -m venv venv
source venv/bin/activate  # On Windows: venv\\Scripts\\activate

# Install dependencies
pip install -r requirements.txt
```"""
        elif 'Node.js' in str(framework) or 'React' in framework or 'Express' in framework:
            return f"""### Prerequisites

- Node.js 18+
- npm or pnpm

### Setup Instructions

```bash
# Clone the repository
git clone {repo_url}

# Navigate to project directory
cd {repo_name}

# Install dependencies
npm install
# or
pnpm install
```"""
        else:
            return f"""### Prerequisites

- Git
- Appropriate runtime (see README)

### Setup Instructions

```bash
# Clone the repository
git clone {repo_url}

# Navigate to project directory
cd {repo_name}

# Follow project-specific setup instructions
```"""
    
    def _get_run_command(self, framework: str, languages: List[str]) -> str:
        """Get appropriate run command based on framework"""
        if 'React' in framework and 'Vite' in framework:
            return """```bash
# Start development server
npm run dev
# or
pnpm dev

# Build for production
npm run build
```"""
        elif 'React' in framework:
            return """```bash
# Start development server
npm start

# Build for production
npm run build
```"""
        elif 'Next.js' in framework:
            return """```bash
# Start development server
npm run dev

# Build for production
npm run build
npm start
```"""
        elif 'Python' in languages and 'FastAPI' in framework:
            return """```bash
# Run the FastAPI server
uvicorn main:app --reload

# Or run directly
python main.py
```"""
        elif 'Python' in languages:
            return """```bash
# Run the application
python main.py

# Or run API server
python api.py
```"""
        else:
            return """```bash
# Run the application
# Check the README or project-specific documentation
```"""

