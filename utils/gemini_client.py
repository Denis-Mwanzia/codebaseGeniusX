"""
Gemini AI Client for Codebase Genius X
Handles Gemini API integration for documentation generation
"""

import os
import google.generativeai as genai
from typing import Dict, Any, Optional, List


class GeminiClient:
    """Client for interacting with Google's Gemini API"""
    
    def __init__(self, api_key: Optional[str] = None):
        self.api_key = api_key or os.getenv('GEMINI_API_KEY')
        if not self.api_key:
            raise ValueError("GEMINI_API_KEY must be provided")
        
        genai.configure(api_key=self.api_key)
        # Initialize model - handle exceptions during generation instead
        # Default to gemini-pro which is known to work
        self.model = genai.GenerativeModel('gemini-pro')
    
    def summarize_readme(self, readme_content: str) -> str:
        """Summarize README content"""
        if not readme_content:
            return "No README found"
        
        prompt = f"""Summarize the following README in 2-3 sentences:

{readme_content[:1000]}

Provide a concise summary of what this project does."""
        
        try:
            response = self.model.generate_content(prompt)
            return response.text
        except Exception as e:
            print(f"🤖 Gemini AI is taking a coffee break: {e} ☕")
            # Fallback to simple summary
            return f"This project is described in the README. The README contains {len(readme_content)} characters."
    
    def generate_documentation(self, context: Dict[str, Any]) -> str:
        """Generate comprehensive documentation"""
        code_graph = context.get('code_graph', {})
        file_tree = context.get('file_tree', {})
        readme_summary = context.get('readme_summary', '')
        
        prompt = f"""You are an expert technical writer. Create professional Markdown documentation with the EXACT structure below.

Repository: {context.get('repo_url', '[GitHub URL]')}
Languages: {', '.join(self._detect_languages(file_tree))}

README Summary:
{readme_summary}

Code Structure:
{self._format_file_tree(file_tree)}

Key Components:
{self._format_code_graph(code_graph)}

Create documentation with these EXACT sections in this order:

# <Project Name>

**Repository:** [GitHub URL]  
**Languages:** [detected languages]  
**Generated by:** Codebase Genius X – The Intelligent Crew 🚀

---

## Overview
[2-3 sentences about what the project does and its purpose]

## Repository Structure
[Show the file tree structure]

## Installation
[Setup instructions]

## Usage
[How to run the project]

## Code Summary
[List functions, classes, and modules]

## Relationships
[Text summary of the Code Context Graph and module relationships]

## Architecture Diagram
[Include Mermaid diagram code]

## API Reference
[Table of endpoints if applicable]

## Dependencies
[List of packages]

## Insights
[Gemini-generated observations about the codebase]

## Conclusion
[Final thoughts]

Use the exact format shown above. Be professional, clear, and concise."""
        
        try:
            response = self.model.generate_content(prompt)
            return response.text
        except Exception as e:
            print(f"🤖 Gemini AI is taking a coffee break: {e} ☕")
            # Return enhanced fallback documentation
            code_graph = context.get('code_graph', {})
            file_tree = context.get('file_tree', {})
            repo_name = file_tree.get('name', 'Project')
            
            # Extract repo URL from context if available
            repo_url = context.get('repo_url', '[GitHub URL]')
            
            # Get metadata
            metadata = file_tree.get('metadata', {})
            languages = metadata.get('languages', []) or self._detect_languages(file_tree)
            framework = metadata.get('framework', 'Not detected')
            build_tool = metadata.get('build_tool', '')
            runtime = metadata.get('runtime', '')
            
            # Format framework info
            framework_info = framework
            if build_tool:
                framework_info += f" + {build_tool}"
            if runtime:
                framework_info += f" ({runtime})"
            
            # Extract dependencies
            dependencies = code_graph.get('dependencies', [])
            deps_text = self._format_dependencies(dependencies)
            
            # Extract code entities
            entities_text = self._format_code_entities(code_graph)
            
            # Determine installation commands based on framework
            install_cmd = self._get_install_command(framework, languages, repo_url, repo_name)
            run_cmd = self._get_run_command(framework, languages)
            
            return f"""# 🚀 {repo_name}
*Where Innovation Meets Implementation*

<div align="center">

![Repository Status](https://img.shields.io/badge/Status-Active-brightgreen)
![Languages](https://img.shields.io/badge/Languages-{'+'.join(languages[:2]) if languages else 'Multi'}-blue)
![Framework](https://img.shields.io/badge/Framework-{framework.replace(' ', '%20') if framework else 'Custom'}-orange)
![AI Powered](https://img.shields.io/badge/AI%20Powered-Codebase%20Genius%20X-purple)

</div>

**🔗 Repository:** {repo_url}  
**💻 Languages:** {', '.join(languages) if languages else 'Python, JavaScript'}  
**⚡ Framework:** {framework_info}  
**🤖 Generated by:** Codebase Genius X – The Intelligent Crew 🚀

---

## 🌟 Project Spotlight

> *"Every great codebase tells a story. This is yours."*

This project represents a thoughtful approach to software development, where each component serves a purpose and every line of code contributes to the greater vision. Through automated analysis, we've uncovered the architectural patterns and design decisions that make this codebase unique.

{self._generate_overview(languages, framework)}

## 🏗️ Architecture Landscape

{self._format_file_tree(file_tree)}

## 🚀 Quick Start Guide

{install_cmd}

## 🎮 Running the Application

{run_cmd}

## 📊 Code Intelligence Report

### Modules Analyzed

{self._format_code_graph(code_graph)}

### Functions & Classes

{entities_text}

## 🔗 System Relationships

The codebase demonstrates a thoughtful modular architecture where each component has a clear responsibility. Like a well-orchestrated symphony, every module plays its part in creating a harmonious whole that follows modern development best practices.

### 🧠 Code Context Graph (CCG)

- **Total Modules**: {len(code_graph.get('modules', {}))}
- **Code Entities**: {len(code_graph.get('nodes', []))}
- **Language Statistics**: {self._format_language_stats(code_graph.get('language_stats', {}))}

## 🎨 Visual Architecture

```mermaid
graph TD
    A[{repo_name}] --> B[Module Structure]
    B --> C[Function Definitions]
    B --> D[Class Definitions]
    
    style A fill:#ff6b6b
    style B fill:#4ecdc4
    style C fill:#95e1d3
    style D fill:#fce38a
```

## 🌐 API Reference

### Endpoints

(API endpoints will be listed here if applicable)

## 📦 Dependency Ecosystem

{deps_text}

## 🔮 AI-Powered Insights

### 🎯 Key Observations

- **🏗️ Architecture**: Well-crafted codebase with intentional structure and clear separation of concerns
- **✨ Code Quality**: Demonstrates adherence to modern development standards and best practices
- **🚀 Scalability**: Built with growth in mind, featuring modular design patterns
- **📚 Documentation**: Enhanced with AI-powered automated documentation generation

### 💡 Smart Recommendations

1. **🎨 Maintain Excellence** - Continue the high code quality standards evident throughout
2. **🧪 Test Coverage** - Expand testing suite to match the quality of the implementation
3. **📖 Living Docs** - Keep documentation synchronized with code evolution
4. **⚡ Automation** - Consider implementing CI/CD pipelines for streamlined development

## 🎭 The Story Behind The Code

This codebase represents more than just functional software—it's a digital narrative of thoughtful development decisions, creative problem-solving, and technical craftsmanship. Each module tells a part of the story, each function serves a purpose, and together they create something greater than the sum of their parts.

## 🏆 Hall of Fame

**🎖️ The Intelligent Crew:**
- 🧭 **Captain** – *The Visionary Orchestrator*
- 🗺️ **Navigator** – *The Path Finder & Repository Mapper*  
- 🔍 **Inspector** – *The Code Detective & Structure Analyzer*
- ✍️ **Author** – *The Documentation Storyteller*
- 🎨 **Designer** – *The Visual Architecture Artist*

---

<div align="center">

*✨ Crafted with AI Intelligence on {self._get_timestamp()} ✨*

**Made with ❤️ by Codebase Genius X – The Intelligent Crew**

</div>"""
    
    def _format_file_tree(self, file_tree: Dict) -> str:
        """Format file tree for prompt"""
        if not file_tree:
            return "No files found"
        
        def format_tree(node, indent=0):
            lines = []
            name = node.get('name', '')
            if node.get('type') == 'directory':
                lines.append("  " * indent + f"📁 {name}/")
            else:
                icon = "📄"
                if name.endswith('.py'):
                    icon = "🐍"
                elif name.endswith('.md'):
                    icon = "📝"
                elif name.endswith('.json'):
                    icon = "📋"
                elif name.endswith('.yml') or name.endswith('.yaml'):
                    icon = "⚙️"
                lines.append("  " * indent + f"{icon} {name}")
            
            for child in node.get('children', []):
                lines.extend(format_tree(child, indent + 1))
            
            return lines
        
        return "\n".join(format_tree(file_tree))
    
    def _format_code_graph(self, code_graph: Dict) -> str:
        """Format code graph for prompt"""
        if not code_graph:
            return "No code analysis available"
        
        modules = code_graph.get('modules', {})
        nodes = code_graph.get('nodes', [])
        
        summary = f"Total: {len(modules)} modules, {len(nodes)} entities\n\n"
        
        # List key modules
        for i, (module_id, module_info) in enumerate(list(modules.items())[:10]):
            summary += f"Module {i+1}: {module_info.get('path', module_id)}\n"
        
        return summary
    
    def _format_code_entities(self, code_graph: Dict) -> str:
        """Format code entities (functions, classes, and components)"""
        if not code_graph:
            return "No code entities found"
        
        nodes = code_graph.get('nodes', [])
        classes = [n for n in nodes if n.get('type') == 'class']
        functions = [n for n in nodes if n.get('type') == 'function']
        components = [n for n in nodes if n.get('type') == 'component']
        
        output = []
        
        if classes:
            output.append(f"### Classes ({len(classes)})")
            for cls in classes[:10]:
                output.append(f"- `{cls.get('name')}` - {cls.get('module', 'unknown')}")
        
        if components:
            output.append(f"\n### React Components ({len(components)})")
            for comp in components[:10]:
                output.append(f"- `{comp.get('name')}` - {comp.get('module', 'unknown')}")
        
        if functions:
            output.append(f"\n### Functions ({len(functions)})")
            for func in functions[:10]:
                output.append(f"- `{func.get('name')}` - {func.get('module', 'unknown')}")
        
        return "\n".join(output) if output else "No code entities found"
    
    def _detect_languages(self, file_tree: Dict) -> list:
        """Detect programming languages from file tree"""
        languages = set()
        
        def scan_tree(node):
            if node.get('type') == 'file':
                name = node.get('name', '')
                if name.endswith('.py'):
                    languages.add('Python')
                elif name.endswith('.js') or name.endswith('.jsx'):
                    languages.add('JavaScript')
                elif name.endswith('.ts') or name.endswith('.tsx'):
                    languages.add('TypeScript')
                elif name.endswith('.java'):
                    languages.add('Java')
                elif name.endswith('.go'):
                    languages.add('Go')
                elif name.endswith('.rs'):
                    languages.add('Rust')
                elif name.endswith('.rb'):
                    languages.add('Ruby')
            
            for child in node.get('children', []):
                scan_tree(child)
        
        scan_tree(file_tree)
        return sorted(list(languages)) if languages else ['Python']
    
    def _get_timestamp(self) -> str:
        """Get current timestamp"""
        from datetime import datetime
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    def generate_diagram(self, code_graph: Dict[str, Any], file_tree: Dict[str, Any]) -> str:
        """🎨 Generate a creative and visually stunning Mermaid diagram from code graph"""
        nodes = code_graph.get('nodes', [])
        modules = code_graph.get('modules', {})
        language_stats = code_graph.get('language_stats', {})
        
        # Group nodes by type for better visualization
        components = [n for n in nodes if n.get('type') == 'component']
        classes = [n for n in nodes if n.get('type') == 'class']
        functions = [n for n in nodes if n.get('type') == 'function']
        
        # Start with creative diagram structure
        project_name = file_tree.get('name', 'Project')
        diagram_lines = [
            "graph TD",
            f"    A[🚀 {project_name}] --> B[📦 Architecture Hub]",
            "    B --> C[⚙️ Function Galaxy]",
            "    B --> D[🏛️ Class Cosmos]",
            "    B --> E[🧩 Component Universe]",
            ""
        ]
        
        # Add language ecosystem if available
        if language_stats:
            diagram_lines.extend([
                "    A --> F[🌐 Language Ecosystem]"
            ])
            node_letter = ord('G')
            for lang, count in list(language_stats.items())[:4]:  # Limit to 4 languages
                letter = chr(node_letter)
                emoji = self._get_language_emoji(lang)
                diagram_lines.append(f"    F --> {letter}[{emoji} {lang}: {count} files]")
                node_letter += 1
            diagram_lines.append("")
        
        # Add top modules with creative names
        if modules:
            diagram_lines.extend([
                "    B --> H[📁 Module Network]"
            ])
            node_letter = ord('I')
            for i, (module_id, module_info) in enumerate(list(modules.items())[:5]):
                letter = chr(node_letter + i)
                module_name = module_info.get('path', module_id).split('/')[-1]
                clean_name = module_name.replace('_', ' ').replace('.py', '').replace('.js', '').replace('.ts', '').title()
                emoji = self._get_module_emoji(module_name)
                diagram_lines.append(f"    H --> {letter}[{emoji} {clean_name}]")
            diagram_lines.append("")
        
        # Add entity counts with visual appeal
        if components:
            diagram_lines.append(f"    E --> EC[🎭 {len(components)} React Components]")
        if classes:
            diagram_lines.append(f"    D --> DC[🏗️ {len(classes)} Class Structures]")
        if functions:
            diagram_lines.append(f"    C --> FC[⚡ {len(functions)} Function Powers]")
        
        # Add creative styling with The Intelligent Crew's touch
        diagram_lines.extend([
            "",
            "    %% 🎨 The Intelligent Crew's Creative Styling",
            "    style A fill:#ff6b6b,stroke:#333,stroke-width:4px,color:#fff",
            "    style B fill:#4ecdc4,stroke:#333,stroke-width:3px,color:#fff", 
            "    style C fill:#95e1d3,stroke:#333,stroke-width:2px,color:#333",
            "    style D fill:#fce38a,stroke:#333,stroke-width:2px,color:#333",
            "    style E fill:#f38181,stroke:#333,stroke-width:2px,color:#fff",
            "    style F fill:#a8e6cf,stroke:#333,stroke-width:2px,color:#333",
            "    style H fill:#dda0dd,stroke:#333,stroke-width:2px,color:#333",
            "",
            "    %% ✨ Add visual flair and personality",
            "    classDef moduleClass fill:#e8f4fd,stroke:#1e88e5,stroke-width:2px,color:#333",
            "    classDef langClass fill:#fff3e0,stroke:#f57c00,stroke-width:2px,color:#333",
            "    classDef entityClass fill:#f3e5f5,stroke:#8e24aa,stroke-width:2px,color:#333",
            "",
            "    %% 🌟 Apply creative classes",
            "    class EC,DC,FC entityClass"
        ])
        
        return "\n".join(diagram_lines)
    
    def _get_language_emoji(self, language: str) -> str:
        """Get emoji for programming language"""
        emoji_map = {
            'Python': '🐍',
            'JavaScript': '⚡',
            'TypeScript': '💙',
            'React': '⚛️',
            'HTML': '🌐',
            'CSS': '🎨',
            'Java': '☕',
            'C++': '⚙️',
            'Go': '🐹',
            'Rust': '🦀'
        }
        return emoji_map.get(language, '📄')
    
    def _get_module_emoji(self, module_name: str) -> str:
        """Get emoji for module based on name"""
        name_lower = module_name.lower()
        if 'api' in name_lower or 'server' in name_lower:
            return '🌐'
        elif 'test' in name_lower:
            return '🧪'
        elif 'util' in name_lower or 'helper' in name_lower:
            return '🔧'
        elif 'config' in name_lower or 'setting' in name_lower:
            return '⚙️'
        elif 'model' in name_lower or 'data' in name_lower:
            return '📊'
        elif 'view' in name_lower or 'component' in name_lower:
            return '🎭'
        elif 'auth' in name_lower or 'security' in name_lower:
            return '🔐'
        elif 'db' in name_lower or 'database' in name_lower:
            return '🗄️'
        else:
            return '📦'
    
    def _generate_overview(self, languages: List[str], framework: str) -> str:
        """Generate a creative and contextual overview"""
        if 'TypeScript' in languages and framework and 'React' in framework:
            return """🎭 **The React Symphony**: A harmonious blend of components dancing together in perfect TypeScript rhythm. This isn't just code—it's a digital masterpiece where every component has a purpose, every hook tells a story, and every state change orchestrates a seamless user experience.

✨ **What makes this special?** Modern React patterns meet cutting-edge development practices, creating an application that's both developer-friendly and user-centric."""
        
        elif 'JavaScript' in languages and framework and 'React' in framework:
            return """⚡ **The React Experience**: A dynamic web application where JavaScript creativity meets component-based architecture. Each interaction is carefully crafted, each animation purposeful, creating a user experience that feels both intuitive and delightful.

🎯 **The Magic?** Pure JavaScript power combined with React's component philosophy, resulting in maintainable and scalable frontend architecture."""
        
        elif 'Python' in languages and framework and 'FastAPI' in framework:
            return """🚀 **The API Powerhouse**: A lightning-fast FastAPI backend that transforms data into digital gold. Built with Python's elegance and async superpowers, this application doesn't just serve requests—it crafts experiences.

🔥 **The Magic?** Type-safe endpoints, automatic documentation, and performance that scales with your ambitions."""
        
        elif 'Python' in languages:
            return """🐍 **The Python Ecosystem**: A carefully crafted collection of modules working in perfect harmony. Like a well-orchestrated symphony, each function plays its part in creating something greater than the sum of its parts.

💫 **The Vision?** Clean, readable code that follows Pythonic principles while solving real-world problems with elegance and efficiency."""
        
        elif 'TypeScript' in languages:
            return """⚡ **The TypeScript Universe**: Where type safety meets innovation. This codebase represents the evolution of JavaScript—from dynamic scripting to sophisticated applications that push the boundaries of what's possible with static typing.

🎯 **The Difference?** Compile-time confidence meets runtime performance, creating a foundation for scalable, maintainable applications."""
        
        else:
            return """💫 **The Code Universe**: A constellation of interconnected elements, each serving a unique purpose in this digital galaxy. This codebase represents the perfect fusion of functionality and artistry.

🎯 **The Vision?** Modern development practices meet innovative solutions, creating a foundation for limitless possibilities."""
    
    def _format_dependencies(self, dependencies: List[Dict]) -> str:
        """Format dependencies list"""
        if not dependencies:
            return "### Required Packages\n\n```\nNo dependencies file found\n```"
        
        deps_list = []
        dev_deps_list = []
        
        for dep in dependencies:
            name = dep.get('name', '')
            version = dep.get('version', 'latest')
            dep_type = dep.get('type', 'dependency')
            
            if dep_type == 'devDependency':
                dev_deps_list.append(f"- {name}: {version}")
            else:
                deps_list.append(f"- {name}: {version}")
        
        output = "### Required Packages\n\n"
        
        if deps_list:
            output += "**Dependencies:**\n\n"
            output += "\n".join(deps_list)
            output += "\n\n"
        
        if dev_deps_list:
            output += "**Dev Dependencies:**\n\n"
            output += "\n".join(dev_deps_list)
            output += "\n\n"
        
        return output.strip()
    
    def _format_language_stats(self, stats: Dict) -> str:
        """Format language statistics"""
        if not stats:
            return "N/A"
        
        stats_str = ", ".join([f"{lang}: {count} files" for lang, count in stats.items()])
        return stats_str
    
    def _get_install_command(self, framework: str, languages: List[str], repo_url: str, repo_name: str) -> str:
        """Get appropriate installation command based on framework"""
        if 'Python' in languages:
            return f"""### Prerequisites

- Python 3.8+
- pip

### Setup Instructions

```bash
# Clone the repository
git clone {repo_url}

# Navigate to project directory
cd {repo_name}

# Create virtual environment
python3 -m venv venv
source venv/bin/activate  # On Windows: venv\\Scripts\\activate

# Install dependencies
pip install -r requirements.txt
```"""
        elif 'Node.js' in str(framework) or 'React' in framework or 'Express' in framework:
            return f"""### Prerequisites

- Node.js 18+
- npm or pnpm

### Setup Instructions

```bash
# Clone the repository
git clone {repo_url}

# Navigate to project directory
cd {repo_name}

# Install dependencies
npm install
# or
pnpm install
```"""
        else:
            return f"""### Prerequisites

- Git
- Appropriate runtime (see README)

### Setup Instructions

```bash
# Clone the repository
git clone {repo_url}

# Navigate to project directory
cd {repo_name}

# Follow project-specific setup instructions
```"""
    
    def _get_run_command(self, framework: str, languages: List[str]) -> str:
        """Get appropriate run command based on framework"""
        if framework and 'React' in framework and 'Vite' in framework:
            return """```bash
# Start development server
npm run dev
# or
pnpm dev

# Build for production
npm run build
```"""
        elif framework and 'React' in framework:
            return """```bash
# Start development server
npm start

# Build for production
npm run build
```"""
        elif framework and 'Next.js' in framework:
            return """```bash
# Start development server
npm run dev

# Build for production
npm run build
npm start
```"""
        elif 'Python' in languages and framework and 'FastAPI' in framework:
            return """```bash
# Run the FastAPI server
uvicorn main:app --reload

# Or run directly
python main.py
```"""
        elif 'Python' in languages:
            return """```bash
# Run the application
python main.py

# Or run API server
python api.py
```"""
        else:
            return """```bash
# Run the application
# Check the README or project-specific documentation
```"""

